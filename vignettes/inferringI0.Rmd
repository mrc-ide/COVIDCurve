---
title: "Inferring I0"
author: "Nick Brazeau and Bob Verity"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Inferring I0}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(123)
```

```{r setup}
library(CurveAware)
```

## Scenario
Here we assume that we only have the cumulative number of deaths on a given day, $t$, of an epidemic with incidence increasing at an exponential rate. Further, we assume that we have a **strong prior belief** of the age-specific infection fatality rates (IFRs) -- presumably from clinical data -- but want to infer the initial number of infected individuals in the epidemic, $I_0$. 

### Simulating Data
Here we will simulate the number of deaths for day 50 of an epidemic that appears to be have a mild IFR for individuals less than 60-years of age ($m_{a1}$) versus individual older than 60 years of age ($m_{a2}$). We assume that have **strong prior knowledge** of the true values of $m_{a1}$ and $m_{a2}$: 0.1 and 0.5, respectively. In addition, we will assume that we know the probability of infection given age, $p_a$, which in the simplest scenario can be represented by the demographics of the population or in more complex scenarios can be represented by the demographics and the expected contact (or mixing rates) of the population. For simplicity, we will assume a "rectangular" population, where the age-groups are in equal proportions in the population. Further we will assume that the epidemic doubling rate, mean delay of onset-to-death, and the coefficient of variation of onset-to-death are known and fixed from [Verity _et al._ 2020](https://www.thelancet.com/journals/laninf/article/PIIS1473-3099(20)30243-7/fulltext).

We will simulate that the $I_0$ was 5 individuals, but our model will reflect that we have **no prior knowledge** of this true value. 

```{r}
casefat <- data.frame(age = c("1:60", "60:100"),
                      cfr = c(0.1, 0.5),
                      pa = 1/2)

simdat <- CurveAware::sim_infxn_2_death_cumulative(
  casefat = casefat,
  I0 = 5,
  r = 0.14,
  m_od = 18.8,
  s_od = 0.45,
  curr_day = 50)

```

The cumulative case data simulation output is a named vector of the total number of deaths:
```{r, echo=F}
simdat.df <- data.frame(AgeGroups = names(simdat), Deaths = unname(simdat) )
knitr::kable(simdat.df)
```


### Running the Model
Here we will load the Cumulative Likelihood and the "strong Ma" prior from our `LogLikePrior_Catalog`. It is important to note, that users will need to update and adapt the likelihood and prior inputs to reflect their project structure. Please see the [Updating the Likelihood and Prior for Your Project] site for further details on recommended project-specific adaptations. You will also need to specify a dataframe of your "free" parameters as described in the [`drjacoby` vignettes](https://github.com/mrc-ide/drjacoby/blob/master/vignettes/). and a "misc-list" that contains the putative current day of the epidemic and the probability of infection given age, $p_a$, for each age group (see above).

```{r, eval=FALSE}
source("LogLikePrior_Catalog/R_cumulative_likelihood.R")
source("LogLikePrior_Catalog/R_strongMa_prior.R")
```

```{r, include=FALSE}
#..................
# Expanding our here so we don't have to worry about path issues
#..................
r_strongMa_prior <- function(params, param_i, misc) {

  I0 <- params["I0"]
  ma1 <- params["ma1"]
  ma2 <- params["ma2"]


  # get prior
  ret <- dunif(I0, min = 1, max = 10, log = TRUE) +
    dbeta(ma1, shape1 = 100, shape2 = 900, log = TRUE) +
    dbeta(ma2, shape1 = 500, shape2 = 500, log = TRUE)

  return(ret)
}

r_cumulative_likelihood <- function(params, param_i, data, misc) {

  # from lancet id paper
  m_od <- 18.8
  r <- 0.14
  s_od <- 0.45

  # store misc item for integral
  curr_day <- misc$curr_day

  # free params
  I0 <- params["I0"]
  ma1 <- params["ma1"]
  ma2 <- params["ma2"]

  # get age specific mortality
  ma <- c(ma1, ma2)

  # integrate for expected incidence mapped onto onset-death time lag
  integrand <- function(t, gr = r){ return(
    I0 * exp(gr*t) * pgamma(curr_day - t, shape = 1/s_od^2, scale = m_od*s_od^2)) }
  integral <- integrate(integrand, lower = -Inf, upper = curr_day)

  # total exp deaths
  exp.deaths <- misc$pa * ma * integral$value

  # poisson LL
  ret <- sum(dpois(x = data$obs_deaths, lambda = exp.deaths, log = T))
  return(ret)

}


```

```{r}
# params
df_params <- data.frame(name = c("ma1", "ma2", "I0"),
                        min = c(0, 0, 1),
                        init = c(0.1, 0.5, 3),
                        max = c(1, 1, 10))

misclist <- list(curr_day = 50, 
                 pa = c(0.5, 0.5))

r_mcmc_out <- CurveAware::wrap_drjacoby_mcmc(
                                    data = simdat,
                                    level = "Cumulative",
                                    df_params = df_params,
                                    misclist = misclist,
                                    LogLike = r_cumulative_likelihood,
                                    LogPrior = r_strongMa_prior,
                                    burnin = 1e3,
                                    samples = 1e3
                                  )
```

Once the fit has finished, you can explore the posterior distributions using plotting functions in `drjacoby`, namely: `drjacoby::plot_par()` and `drjacoby::plot_cor()`. For further discussions on MCMC diagnostics and assessing MCMC convergence please see the [`drjacoby` vignettes](https://github.com/mrc-ide/drjacoby/blob/master/vignettes/).  
  
Below, the posterior distribution is shown with the simulated true value indicated in as a red line for each free parameter.    

<br/>

```{r, echo=F, fig.height= 15, fig.width=6, fig.align='center'}
library(ggplot2)
ma1plot <- drjacoby::plot_par(r_mcmc_out, "ma1", display = F)
ma1plot[[1]][[2]] <- ma1plot[[1]][[2]] +
  geom_vline(xintercept = casefat$cfr[1], color = "red", size = 2)
bottomrow <- cowplot::plot_grid(ma1plot[[1]][[2]], ma1plot[[1]][[3]], ncol = 2)
ma1plot <- cowplot::plot_grid(ma1plot[[1]][[1]], bottomrow, nrow = 2)
                   
ma2plot <- drjacoby::plot_par(r_mcmc_out, "ma2", display = F)
ma2plot[[1]][[2]] <- ma2plot[[1]][[2]] +
  geom_vline(xintercept = casefat$cfr[2], color = "red", size = 2)
bottomrow <- cowplot::plot_grid(ma2plot[[1]][[2]], ma2plot[[1]][[3]], ncol = 2)
ma2plot <- cowplot::plot_grid(ma2plot[[1]][[1]], bottomrow, nrow = 2)


I0plot <- drjacoby::plot_par(r_mcmc_out, "I0", display = F)
I0plot[[1]][[2]] <- I0plot[[1]][[2]] +
  geom_vline(xintercept = 5, color = "red", size = 2)
bottomrow <- cowplot::plot_grid(I0plot[[1]][[2]], I0plot[[1]][[3]], ncol = 2)
I0plot <- cowplot::plot_grid(I0plot[[1]][[1]], bottomrow, nrow = 2)

cowplot::plot_grid(ma1plot, ma2plot, I0plot, ncol = 1)
```




